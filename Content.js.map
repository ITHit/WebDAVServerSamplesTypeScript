{"version":3,"file":"Content.js","sourceRoot":"","sources":["Content.ts"],"names":[],"mappings":";;AAAA;;GAEG;AACH,IAAiB,KAAK,CA2HrB;AA3HD,WAAiB,KAAK;IAAC,IAAA,MAAM,CA2H5B;IA3HsB,WAAA,MAAM;QAAC,IAAA,MAAM,CA2HnC;QA3H6B,WAAA,MAAM;YAEhC;;;eAGG;YACH,MAAa,OAAO;gBAChB,IAAI;gBACJ;;mBAEG;gBACH;oBACI,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;oBACvB,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC;oBACxB,IAAI,CAAC,KAAK,GAAG,EAAE,CAAC;gBACpB,CAAC;gBAGD,EAAE;gBACF;;;;;;;;mBAQG;gBACH,IAAI,WAAW;oBACX,OAAO,IAAI,CAAC,YAAY,CAAC;gBAC7B,CAAC;gBAGD,GAAG;gBACH;;;mBAGG;gBACH,IAAI,aAAa;oBACb,OAAO,IAAI,CAAC,cAAc,CAAC;gBAC/B,CAAC;gBACD,MAAM;gBACN;;;;;;;;;;;;;mBAaG;gBACH,IAAI,CAAC,MAA6B,EAAE,UAAkB,EAAE,KAAa;oBACjE,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE,GAAE,OAAO,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAA,CAAA,CAAC,CAAC,CAAC;gBAC3E,CAAC;gBACD,OAAO;gBACP;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBA6CG;gBACH,KAAK,CAAC,OAA2B,EAAE,WAAmB,EAAE,UAAkB,EAAE,aAAqB;oBAC7F,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE,GAAE,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC,CAAA,CAAA,CAAC,CAAC,CAAC;gBAC1E,CAAC;gBAGD,GAAG;gBACH;;;;;;mBAMG;gBACH,IAAI,IAAI;oBACJ,OAAO,IAAI,CAAC,KAAK,CAAC;gBACtB,CAAC;aACJ;YApHY,cAAO,UAoHnB,CAAA;QACL,CAAC,EA3H6B,MAAM,GAAN,aAAM,KAAN,aAAM,QA2HnC;IAAD,CAAC,EA3HsB,MAAM,GAAN,YAAM,KAAN,YAAM,QA2H5B;AAAD,CAAC,EA3HgB,KAAK,GAAL,aAAK,KAAL,aAAK,QA2HrB","sourcesContent":["/**\r\n * @copyright Copyright (c) 2017 IT Hit. All rights reserved.\r\n */\r\nexport namespace ITHit.WebDAV.Server\r\n{\r\n    /**\r\n     * Base interface for items that have content, like @see IFileAsync.\r\n     * TODO: does this need to be a separate interface?\r\n     */\r\n    export class Content {\r\n        /// \r\n        /**\r\n         * Initializes new instance.\r\n         */\r\n        constructor () {\r\n            this._ContentType = '';\r\n            this._ContentLength = 0;\r\n            this._Etag = '';\r\n        }\r\n        \r\n        private _ContentType:string;\r\n        //\r\n        /**\r\n         * Gets the media type of the file.\r\n         * The mime-type provided by this property is returned in a Content-Type header with GET request.\r\n         * When deciding which action to perform when downloading a file some WebDAV clients and browsers \r\n         * (such as Internet Explorer) rely on file extension, while others (such as Firefox) rely on Content-Type\r\n         * header returned by server. For identical behavior in all browsers and WebDAV clients your server must\r\n         * return a correct mime-type with a requested file.\r\n         * @returns {string} The MIME type of the file.\r\n         */\r\n        get ContentType(): string {\r\n            return this._ContentType;\r\n        }\r\n         \r\n        private _ContentLength:number;\r\n        ///\r\n        /**\r\n         * Gets the size of the file content in bytes.\r\n         * @returns {number}  Length of the file content in bytes.\r\n         */\r\n        get ContentLength(): number {\r\n            return this._ContentLength;\r\n        }\r\n        ///   \r\n        /**\r\n         * Reads the file content from the repository and writes it to the specified stream.\r\n         * By default ASP.NET buffers content on server side before sending output. You must turn off buffering to\r\n         * eliminate keeping entire file content in memory before sending:\r\n         * Client application can request only a part of a file specifying @b  Range header. Download managers \r\n         * may use this header to download single file using several threads at a time.\r\n         * @param output Output stream.\r\n         * @param startIndex The zero-bazed byte offset in file content at which to begin copying bytes to\r\n         * the output stream.\r\n         * @param count The number of bytes to be written to the output stream.\r\n         * @exception NeedPrivilegesException The user doesn't have enough privileges.\r\n         * @exception DavException In other cases.\r\n         * @example <caption>HttpContext.Current.Response.BufferOutput = false;</caption>\r\n         */\r\n        Read(output: NodeJS.ReadableStream, startIndex: number, count: number): Promise<any>{\r\n            return new Promise((resolve, reject) => {resolve(output.read(count))});\r\n        }\r\n        ///    \r\n        /**\r\n         * Saves the content of the file from the specified stream to the WebDAV repository.\r\n         * @param content Stream to read the content of the file from.\r\n         * @param contentType Indicates the media type of the file.\r\n         * @param startIndex Start offset to which content shall be saved.\r\n         * @param totalFileSize Entire length of the file. Is is not less then length of @paramref content  stream.\r\n         * @returns Boolean value indicating whether entire stream was written. This value is used by engine to take decision whether autocheckin shall be performed.\r\n         * @exception {LockedException} The file was locked and client did not provide lock token.\r\n         * @exception {NeedPrivilegesException} The user doesn't have enough privileges.\r\n         * @exception {InsufficientStorageException} Quota limit is reached.\r\n         * @exception {DavException} In other cases.\r\n         * @desc  IIS and ASP.NET does not support files upload larger than 2Gb. If you need to upload files larger\r\n         * than 2Gb you must develop HttpListener-based WebDAV server or implement resumable upload interfaces.\r\n         * If you are creating HttpHandler-based WebDAV server you must specify the file \r\n         * maximum upload size in web.config of your web application. By default maximum \r\n         * upload size is set to 4096 KB (4 MB) by ASP.NET. This limit is used to \r\n         * prevent denial of service attacks caused by users posting large files to the \r\n         * server. To increase the upload limit add &lt;httpRuntime&gt; section to your web application web.config\r\n         * file and specify the limit in kilobytes:\r\n         * @example &lt;![CDATA[\r\n         * @example &nbsp;&nbsp;&lt;configuration&gt;\r\n         * @example &nbsp;&nbsp;&nbsp;&nbsp;&lt;system.web&gt;\r\n         * @example &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...\r\n         * @example &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;httpRuntime maxRequestLength=\"2097151\" /&gt; //2Gb\r\n         * @example &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...\r\n         * @example &nbsp;&nbsp;&nbsp;&nbsp;&lt;/system.web&gt;\r\n         * @example &nbsp;&nbsp;&lt;/configuration&gt;\r\n         * @example ]]&gt;\r\n         * @desc When client uploads file to IIS, ASP.NET first creates the file in a the temporary upload directory.\r\n         * Only when the entire file is uploaded to server you can read its content from stream. By default ASP.NET\r\n         * uploads files to @b  %FrameworkInstallLocation%\\Temporary ASP.NET Files folder.\r\n         * You must make sure you have enough disk space to keep temporary files uploaded to your server.\r\n         * To change this folder location add the following section to your web.config file:.\r\n         * @example &lt;![CDATA[\r\n         * @example &nbsp;&nbsp;&lt;configuration&gt;\r\n         * @example &nbsp;&nbsp;&nbsp;&nbsp;&lt;system.web&gt;\r\n         * @example &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...\r\n         * @example &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;compilation tempDirectory=&quot;temporary files directory&quot; /&gt;\r\n         * @example &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...\r\n         * @example &nbsp;&nbsp;&nbsp;&nbsp;&lt;/system.web&gt;\r\n         * @example &nbsp;&nbsp;&lt;/configuration&gt;\r\n         * @example ]]&gt;\r\n         * @desc To avoid temporary file creation and pass content directly to engine set the @see ITHit.WebDAV.Server.ResumableUpload.PutUploadProgressAndResumeModule \r\n         * module in your web.config file. Unlike IIS/ASP.NET, HttpListener-based server does not create any\r\n         * temporary files when handling uploads.\r\n         */\r\n        Write(content: NodeJS.WriteStream, contentType: string, startIndex: number, totalFileSize: number): Promise<boolean>{\r\n            return new Promise((resolve, reject) => {resolve(content.write(''))});\r\n        }\r\n        \r\n        private _Etag : string;\r\n        ///\r\n        /**\r\n         * Gets entity tag - string that identifies current state of resource's content.\r\n         * More information about etags is available here: http://en.wikipedia.org/wiki/HTTP_ETag\r\n         * You can return here either cheksum or hash or counter which increases with every modification.\r\n         * This property shall return different value if content changes.\r\n         * @returns {string} null to indicate that server doesn't support etags.\r\n         */\r\n        get Etag(): string {\r\n            return this._Etag;\r\n        }\r\n    }\r\n}\r\n"]}